"""
Parser for ONE Simulator MessageStatsReport files.

This module handles the parsing and processing of MessageStatsReport files
generated by the ONE simulator.
"""
import os
import re
import logging
from pathlib import Path
from typing import Dict, List, Tuple, Any, Optional
import matplotlib.pyplot as plt
import numpy as np
from collections import defaultdict

from .config import INPUT_DIR, OUTPUT_DIR, STATS_FILE_PATTERN, FIGURE_DPI, FIGURE_SIZE
from .config import LINE_STYLES, MARKERS, COLORS, METRICS, TIME_METRICS

logger = logging.getLogger(__name__)

class MessageStatsParser:
    """Parse and process MessageStatsReport files from ONE simulator."""

    def __init__(self, input_dir: Path = INPUT_DIR, output_dir: Path = OUTPUT_DIR):
        """Initialize with input and output directories."""
        self.input_dir = input_dir
        self.output_dir = output_dir
        self.data = defaultdict(lambda: defaultdict(dict))

    def parse_file(self, file_path: Path) -> Dict[str, Any]:
        """Parse a single MessageStatsReport file."""
        logger.info(f"Parsing file: {file_path}")

        metrics = {}
        try:
            with open(file_path, 'r') as f:
                content = f.read()

            # Extract all metrics using regex
            for line in content.splitlines():
                if ":" in line and not line.startswith("Message stats"):
                    key, value = line.split(":", 1)
                    key = key.strip()
                    value = value.strip()

                    # Convert numeric values
                    try:
                        if value.lower() == "nan":
                            metrics[key] = float('nan')
                        else:
                            metrics[key] = float(value)
                    except ValueError:
                        metrics[key] = value

            return metrics

        except Exception as e:
            logger.error(f"Failed to parse {file_path}: {e}")
            return {}

    def extract_config_params(self, filename: str) -> Tuple[str, str, float]:
        """Extract router name and configuration parameters from filename."""
        match = re.match(STATS_FILE_PATTERN, filename)
        if not match:
            logger.warning(f"Filename {filename} doesn't match expected pattern")
            return None, None, None

        router_name = match.group(1)
        config_str = match.group(2)

        # Handle parameters like MsgTtl@600
        if '@' in config_str:
            param_name, param_value = config_str.split('@', 1)
            try:
                param_value = float(param_value)
            except ValueError:
                logger.warning(f"Could not convert parameter value to float: {param_value}")
        else:
            param_name = config_str
            param_value = None

        return router_name, param_name, param_value

    def collect_data(self) -> None:
        """Collect data from all MessageStatsReport files in input directory."""
        logger.info(f"Collecting data from {self.input_dir}")

        # Check if input directory exists
        if not self.input_dir.exists():
            logger.error(f"Input directory does not exist: {self.input_dir}")
            return

        # Get all MessageStatsReport files
        report_files = list(self.input_dir.glob("*_MessageStatsReport.txt"))
        if not report_files:
            logger.warning(f"No MessageStatsReport files found in {self.input_dir}")
            return

        logger.info(f"Found {len(report_files)} report files")

        # Process each file
        for file in report_files:
            router_name, param_name, param_value = self.extract_config_params(file.name)
            if not all([router_name, param_name is not None]):
                logger.warning(f"Could not extract parameters from filename: {file.name}")
                continue

            if param_value is None:
                logger.warning(f"Could not extract parameter value from filename: {file.name}")
                continue

            logger.info(f"Processing {router_name} with {param_name}={param_value}")
            metrics = self.parse_file(file)
            if metrics:
                self.data[router_name][param_name][param_value] = metrics
            else:
                logger.warning(f"No metrics extracted from {file.name}")

        # Log summary of collected data
        routers = list(self.data.keys())
        logger.info(f"Collected data for {len(routers)} routers: {', '.join(routers)}")

    def generate_graphs(self) -> None:
        """Generate graphs for each router and metric."""
        if not self.data:
            logger.warning("No data to generate graphs from")
            return

        for router_name, param_data in self.data.items():
            for param_name, param_values in param_data.items():
                for metric_key, metric_name in METRICS.items():
                    try:
                        self._create_graph(router_name, param_name, param_values, metric_key, metric_name)
                    except Exception as e:
                        logger.error(f"Failed to create graph for {router_name}-{param_name}-{metric_key}: {e}")

    def _create_graph(self, router_name: str, param_name: str, param_values: Dict[float, Dict],
                     metric_key: str, metric_name: str) -> None:
        """Create a single graph for a specific router, parameter and metric."""
        # Skip if no data points available for this metric
        x_values = sorted(param_values.keys())
        y_values = [param_values[x].get(metric_key, float('nan')) for x in x_values]

        # Filter out NaN values
        valid_points = [(x, y) for x, y in zip(x_values, y_values) if not np.isnan(y)]
        if not valid_points:
            logger.warning(f"No valid data points for {router_name}-{param_name}-{metric_key}")
            return

        x_values, y_values = zip(*valid_points)

        plt.figure(figsize=FIGURE_SIZE)
        plt.plot(x_values, y_values,
                 marker=MARKERS[0],
                 linestyle=LINE_STYLES[0],
                 color=COLORS[0],
                 linewidth=2,
                 markersize=8)

        plt.title(f"{router_name}: {metric_name} vs {param_name}")
        plt.xlabel(param_name)
        plt.ylabel(metric_name)
        plt.grid(True, linestyle='--', alpha=0.7)

        # Format x-axis as integers if they appear to be
        if all(x.is_integer() for x in x_values):
            plt.xticks(x_values)

        # Save the figure
        output_file = self.output_dir / f"{router_name}_{param_name}_{metric_key}.png"
        plt.savefig(output_file, dpi=FIGURE_DPI, bbox_inches='tight')
        plt.close()

        logger.info(f"Created graph: {output_file}")

    def process(self) -> None:
        """Process all files and generate graphs."""
        self.collect_data()
        self.generate_graphs()


def process_all_reports():
    """Main function to process all message stats reports."""
    parser = MessageStatsParser()
    parser.process()


if __name__ == "__main__":
    process_all_reports()